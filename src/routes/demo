productRoutes.js

const express = require("express");
const productController = require("../controllers/productController");

const router = express.Router();

// Import the upload middleware from productController
const { upload } = productController;

// Routes
router.post("/", upload.single("image"), productController.createProduct);
router.get("/", productController.getAllProducts);
router.get("/discounted", productController.getDiscountedProducts);
router.get("/bestsellers", productController.getBestSellers);
router.get("/nondiscount", productController.getNonDiscountedProducts);
router.get("/:id", productController.getProductById);
router.get("/category/:categoryId", productController.getProductsByCategory);
router.put("/:id", upload.single("image"), productController.updateProduct);
router.delete("/:id", productController.deleteProduct);

// Error Handling Middleware for Multer
router.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    return res.status(400).json({ message: err.message });
  } else if (err) {
    return res.status(400).json({ message: err.message });
  }
  next();
});

module.exports = router;

productController.js

const { S3Client, DeleteObjectCommand } = require("@aws-sdk/client-s3"); // AWS SDK v3
const multerS3 = require("multer-s3");
const path = require("path");
const multer = require("multer");
const mongoose = require("mongoose");
const Product = require("../models/Product");
const Category = require("../models/Category");

// Configure AWS S3 (SDK v3)
const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  },
});

// Multer configuration for S3 (SDK v3)
const upload = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.AWS_BUCKET_NAME,
    metadata: (req, file, cb) => {
      cb(null, { fieldName: file.fieldname });
    },
    key: (req, file, cb) => {
      const ext = path.extname(file.originalname);
      const fileName = `${Date.now()}${ext}`;
      cb(null, fileName);
    },
  }),
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 
      'image/bmp', 'image/tiff', 'image/svg+xml', 'image/avif', 
      'application/octet-stream']; // Add 'application/octet-stream' for AVIF fallback
    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.svg', '.webp', '.avif'];

    const ext = path.extname(file.originalname).toLowerCase();

    if (allowedMimeTypes.includes(file.mimetype) || allowedExtensions.includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error(`Unsupported file format: ${file.mimetype} (${ext})`), false);
    }
  },
});

// Helper function to get full image URL
const getImageUrl = (imageName) =>
  imageName ? `https://${process.env.AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${imageName}` : null;

// Create a new product
exports.createProduct = async (req, res) => {
  console.log("ðŸ“ Raw Request Body:", req.body);
  console.log("ðŸ“¸ Uploaded File:", req.file);

  try {
    const {
      name,
      price,
      shortDescription,
      fullDescription,
      stockQuantity,
      category,
      discount,
      hasDiscount,
    } = req.body;

    // Validation for required fields
    if (!name || name.trim() === "") {
      return res.status(400).json({ message: "Name is required" });
    }

    // Check if the category exists
    const existingCategory = await Category.findById(category);
    if (!existingCategory) {
      return res.status(400).json({ message: "Invalid category ID" });
    }

    // Create a new product with optional discount
    const newProduct = new Product({
      name: name.trim(),
      price,
      shortDescription,
      fullDescription,
      stockQuantity,
      category,
      image: req.file ? req.file.key : null, // Store the S3 key
      discount: hasDiscount === "true" ? discount : 0, // Only apply discount if `hasDiscount` is true
      hasDiscount: hasDiscount === "true", // Convert to boolean
    });

    await newProduct.save();

    // Populate the category field
    const populatedProduct = await Product.findById(newProduct._id).populate("category", "name");

    // Include the full image URL in the response
    const responseProduct = {
      ...populatedProduct.toObject(),
      photo: populatedProduct.image ? getImageUrl(populatedProduct.image) : null,
    };

    res.status(201).json(responseProduct);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Update product with sold count and adjust stock
exports.updateProduct = async (req, res) => {
  try {
    const {
      name,
      price,
      shortDescription,
      fullDescription,
      stockQuantity,
      category,
      discount,
      hasDiscount,
      sold, // User-provided sold count
    } = req.body;

    const product = await Product.findById(req.params.id);
    if (!product) return res.status(404).json({ message: "Product not found" });

    let updateData = {};

    if (name) updateData.name = name;
    if (price) updateData.price = price;
    if (shortDescription) updateData.shortDescription = shortDescription;
    if (fullDescription) updateData.fullDescription = fullDescription;
    if (discount !== undefined) updateData.discount = hasDiscount === "true" ? discount : 0;
    if (hasDiscount !== undefined) updateData.hasDiscount = hasDiscount === "true";

    // âœ… Check if sold increased
    if (sold !== undefined) {
      const newSold = Number(sold);
      if (newSold < product.sold) {
        return res.status(400).json({ message: "Sold count cannot decrease" });
      }

      const increaseInSold = newSold - product.sold;
      if (increaseInSold > 0) {
        // âœ… Reduce stockQuantity accordingly
        const newStockQuantity = product.stockQuantity - increaseInSold;
        if (newStockQuantity < 0) {
          return res.status(400).json({ message: "Not enough stock available" });
        }
        updateData.stockQuantity = newStockQuantity;
      }

      updateData.sold = newSold;
    }

    // âœ… Allow stockQuantity to be updated only if provided
    if (stockQuantity !== undefined) {
      updateData.stockQuantity = Number(stockQuantity);
    }

    // Validate and update category
    if (category) {
      try {
        const existingCategory = await Category.findById(category);
        if (!existingCategory) return res.status(400).json({ message: "Invalid category ID" });
        updateData.category = category;
      } catch (error) {
        return res.status(400).json({ message: "Invalid category format" });
      }
    }

    // Handle image upload
    if (req.file) {
      // Delete the old image from S3 if it exists
      if (product.image) {
        try {
          await s3.send(new DeleteObjectCommand({
            Bucket: process.env.AWS_BUCKET_NAME,
            Key: product.image,
          }));
          console.log("Old image deleted from S3:", product.image);
        } catch (error) {
          console.error("Error deleting old image from S3:", error);
        }
      }
      updateData.image = req.file.key; // Store the new S3 key
    }

    // Update product
    const updatedProduct = await Product.findByIdAndUpdate(req.params.id, updateData, { new: true });

    if (!updatedProduct) return res.status(404).json({ message: "Product not found" });

    // Include the full image URL in the response
    const responseProduct = {
      ...updatedProduct.toObject(),
      photo: updatedProduct.image ? getImageUrl(updatedProduct.image) : null,
    };

    res.json({ message: "Product updated successfully", product: responseProduct });
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};
// Get top 5 best-selling products
exports.getBestSellers = async (req, res) => {
  try {
    const bestSellers = await Product.find()
      .sort({ sold: -1 }) // Sort by highest sold first
      .limit(5)
      .populate("category", "name");

    const productsWithRanking = bestSellers.map((product, index) => ({
      rank: index + 1, // Assign rank from 1 to 5
      _id: product._id,
      name: product.name,
      shortDescription: product.shortDescription, // Include shortDescription
      fullDescription: product.fullDescription, // Include fullDescription
      category: product.category ? product.category.name : "Uncategorized",
      price: product.price,
      sold: product.sold,
      stockQuantity: product.stockQuantity,
      image: product.image, // S3 key
      photo: product.image ? getImageUrl(product.image) : null, // Full S3 URL
    }));

    res.json(productsWithRanking);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get products with no discount
exports.getNonDiscountedProducts = async (req, res) => {
  try {
    const nonDiscountedProducts = await Product.find({
      hasDiscount: false,
      discount: 0,
    }).populate("category", "name");

    const productsWithImageUrl = nonDiscountedProducts.map((product) => ({
      _id: product._id,
      name: product.name,
      shortDescription: product.shortDescription, // Include shortDescription
      fullDescription: product.fullDescription, // Include fullDescription
      category: product.category ? product.category.name : "Uncategorized",
      price: product.price,
      hasDiscount: product.hasDiscount,
      discount: product.discount,
      image: product.image, // S3 key
      photo: product.image ? getImageUrl(product.image) : null, // Full S3 URL
    }));

    res.json(productsWithImageUrl);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get all products
exports.getAllProducts = async (req, res) => {
  try {
    const products = await Product.find().populate("category", "name");
    // Add the base URL for the image
    const productsWithImageUrl = products.map(product => ({
      ...product.toObject(),
      shortDescription: product.shortDescription, // Include shortDescription
      fullDescription: product.fullDescription, // Include fullDescription
      image: product.image, // S3 key
      photo: product.image ? getImageUrl(product.image) : null, // Full S3 URL
    }));
    res.json(productsWithImageUrl);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get product by ID
exports.getProductById = async (req, res) => {
  try {
    const product = await Product.findById(req.params.id).populate("category", "name");
    if (!product) return res.status(404).json({ message: "Product not found" });
    // Add the base URL for the image
    const responseProduct = {
      ...product.toObject(),
      image: product.image, // S3 key
      photo: product.image ? getImageUrl(product.image) : null, // Full S3 URL
    };
    res.json(responseProduct);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get discounted products
exports.getDiscountedProducts = async (req, res) => {
  try {
    const discountedProducts = await Product.find({
      hasDiscount: true,
      discount: { $gt: 0 },
    }).populate("category", "name");

    const productsWithImageUrl = discountedProducts.map((product) => ({
      _id: product._id,
      name: product.name,
      shortDescription: product.shortDescription, // Include shortDescription
      fullDescription: product.fullDescription, // Include fullDescription
      category: product.category ? product.category.name : "Uncategorized",
      price: product.price,
      discount: product.discount,
      originalPrice: product.price,
      calculatedPrice: product.price - (product.price * product.discount) / 100,
      hasDiscount: product.hasDiscount,
      image: product.image, // S3 key
      photo: product.image ? getImageUrl(product.image) : null, // Full S3 URL
    }));

    res.json(productsWithImageUrl);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Delete product
exports.deleteProduct = async (req, res) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) return res.status(404).json({ message: "Product not found" });

    // Delete the image from S3 if it exists
    if (product.image) {
      try {
        await s3.send(new DeleteObjectCommand({
          Bucket: process.env.AWS_BUCKET_NAME,
          Key: product.image,
        }));
        console.log("Image deleted from S3:", product.image);
      } catch (error) {
        console.error("Error deleting image from S3:", error);
      }
    }

    await product.deleteOne();
    res.json({ message: "Product deleted successfully" });
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get products by category
exports.getProductsByCategory = async (req, res) => {
  try {
    const categoryId = req.params.categoryId;

    // Validate category ID
    if (!mongoose.Types.ObjectId.isValid(categoryId)) {
      return res.status(400).json({ message: "Invalid category ID" });
    }

    // Check if the category exists
    const category = await Category.findById(categoryId);
    if (!category) {
      return res.status(404).json({ message: "Category not found" });
    }

    // Fetch products by category
    const products = await Product.find({ category: categoryId }).populate("category", "name");

    // Add the base URL for the image
    const productsWithImageUrl = products.map((product) => ({
      _id: product._id,
      name: product.name,
      shortDescription: product.shortDescription, // Include shortDescription
      fullDescription: product.fullDescription, // Include fullDescription
      category: product.category ? product.category.name : "Uncategorized",
      price: product.price,
      discount: product.discount,
      hasDiscount: product.hasDiscount,
      image: product.image, // S3 key
      photo: product.image ? getImageUrl(product.image) : null, // Full S3 URL
    }));

    res.json(productsWithImageUrl);
  } catch (error) {
    console.error("Error fetching products by category:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Export the upload middleware
module.exports.upload = upload;

Product.js

const mongoose = require("mongoose");

const productSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    price: { type: Number, required: true },
    shortDescription: { type: String, required: true },
    fullDescription: { type: String, required: true },
    stockQuantity: { type: Number, required: true },
    sold: { type: Number, required: false, default: 0 },
    category: { type: mongoose.Schema.Types.ObjectId, ref: "Category", required: true },
    image: { type: String, required: false },
    discount: { type: Number, required: false, default: 0 },
    hasDiscount: { type: Boolean, required: false, default: false },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Product", productSchema);